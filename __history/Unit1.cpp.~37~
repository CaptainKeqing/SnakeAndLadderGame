//---------------------------------------------------------------------------

#include <fmx.h>
#pragma hdrstop

#include "Unit1.h"
#include "main.h"
#include "Board.h"
#include "Grid2D.h"
#include "PlayerClass.h"
#include <vector>
#include <random>
#include <ctime>
#include <chrono>
#include <thread>
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.fmx"
TForm1 *Form1;
//Player me{ "Donovan" };
//Player angie{ "Angie" };
//std::vector<Player> players{me, angie};

Player* player1{ new Player{} };
Player* player2{ new Player{} };
Player* player3{ new Player{} };
Player* player4{ new Player{} };
std::vector<Player*> playersVector{ player1, player2, player3, player4 };

int playersPlaying{};
static int global_playerTurnCounter{ 0 };
static int global_max_players{ 4 };
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
	setupRandomiser();
//	for (int i = 0; i < Player::playerCount; ++i){
//		TasksListBox->Items->Add("player");
//	}
	for (int i = 0; i < 4; ++i){
		TasksListBox->Items->Add("initialising image");
		TImage* playerImg;
		playerImg = new TImage(Form1);
		playerImg->Parent = Form1;
		playerImg->Width = 50;
		playerImg->Height = 50;
		playerImg->Position->X = i * 30 + 3;
		playerImg->Position->Y = 542.4;
		playerImg->Bitmap->Assign(
			ImageList1->Bitmap(playerImg->Size->Size, i));

		playersVector[i]->playerImage = playerImg;
//		playersVector[i]->playerImage->Visible = 1;
	}
}
//---------------------------------------------------------------------------
Player* getTurn()
{
	return playersVector[global_playerTurnCounter++ % playersPlaying];
}
//---------------------------------------------------------------------------
int findByValue(std::map<int, int>& mapToLook, int valueToFind) {
	// returns the Key of the corresponding value found, otherwise returns -1;
	auto current{ mapToLook.begin() };
	while (current != mapToLook.end()) {
		if (current->second == valueToFind) {
			return current->first;
		}
		++current;
	}
	return -1;
}
//---------------------------------------------------------------------------
int mainMove(Player* player, int steps){
	player->move(steps);
	int stepOnPlayer{ findByValue(Board::occupiedPositions, player->getGrid()) };
	if (stepOnPlayer != -1){
		// stepped on somebody
		Board::occupiedPositions[stepOnPlayer] =
			Board::occupiedPositions[player->getID()];

		// technically i can probably optimise this by not recalculating where
		// i was but im too tired now. Stepping doesn't happen too often anyws.
		int previousPos{ player->getGrid() - steps };
		int rowIndex{};
		int columnIndex{};
		Grid2D::convertGridToRowColumnOut(previousPos, rowIndex, columnIndex);
		playersVector[stepOnPlayer]->resetPos(
			Board::horizontalCoords[rowIndex], Board::verticalCoords[columnIndex]);
	}
	Board::occupiedPositions[player->getID()] = player->getGrid();
	if (stepOnPlayer != -1){
		return stepOnPlayer;
	}
	return -1;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::RollDiceClick(TObject *Sender)
{
	int randNum{ getRandomNumber(1, 6) };
	TasksListBox->Items->Clear();
	TasksListBox->Items->Insert(0, "Rolling... ");

//	std::this_thread::sleep_for(static_cast<std::chrono::milliseconds>(500));
	TasksListBox->Items->Insert(1, randNum);

	Player* currentPlayer = getTurn();

	TasksListBox->Items->Insert(1, currentPlayer->getID());


	mainMove(currentPlayer, randNum);


//	me.move(randNum);
//
//	double x{me.getPos()[0]};
//	double y{me.getPos()[1]};
//	PlayerImage->Position->X = x;
//	PlayerImage->Position->Y = y;

}
//---------------------------------------------------------------------------
void __fastcall TForm1::TasksListBoxItemClick(TCustomListBox * const Sender, TListBoxItem * const Item)

{
	int index{ Item->Index };
	TasksListBox->Items->Delete(Item->Index);
}
//---------------------------------------------------------------------------
// void Grid2D::traverseImage(int positionToGo, Timage* image) {
//	int rowIndex{};
//	int columnIndex{};
//	if (positionToGo % 10 == 0) {
//		rowIndex = positionToGo / 10 - 1;
//		columnIndex = (rowIndex % 2 == 0 ? 9 : 0);
//	}
//	else {
//		rowIndex = positionToGo / 10;
//		// check even or odd row
//		if (rowIndex % 2 == 0) {
//			columnIndex = positionToGo % 10 - 1;
//		}
//		else {
//			columnIndex = 10 - positionToGo % 10;
//		}
//	}
//	image->Position->X = Board::horizontalCoords[columnIndex];
//	image->Position->Y = Board::verticalCoords[rowIndex];
//}



//---------------------------------------------------------------------------



void __fastcall TForm1::StartGameClick(TObject *Sender)
{
	// brute force is the only way i can do it, tried for damn long
	if (RadioButton1->IsChecked){
		playersPlaying = 1;
	}
	if (RadioButton2->IsChecked){
		playersPlaying = 2;
	}
	if (RadioButton3->IsChecked){
		playersPlaying = 3;
	}
	if (RadioButton4->IsChecked){
		playersPlaying = 4;
	}
	TasksListBox->Items->Add(playersPlaying);

	for (int i = 0; i < 4; ++i){
		if (i < playersPlaying)
			playersVector[i]->playerImage->Visible = 1;
		else
			playersVector[i]->playerImage->Visible = 0;
	}
//	while (true){
//	for (Player& player : players) {
//		TasksListBox->Items->Clear();
//		TasksListBox->Items->Insert(0, "Click button to roll dice.");
//		TasksListBox->Items->Insert(0, (player.getName().c_str()));
//
//		// replacing playerTurn
//		if (player.hasWon) {
//			std::cout << player.getName() << " won!\n";
//			break;
//			}
//		}
//	}
}
//---------------------------------------------------------------------------
//void playerTurn(Player& player) {
//	TasksListBox->Items->Clear();
//	TasksListBox->Items->Insert(0, "Click button to roll dice.");
//	Task
//	std::cin.ignore();
//	int randNum{ getRandomNumber(1, 6) };
//	std::cout << "Rolling... ";
//	std::this_thread::sleep_for(static_cast<std::chrono::milliseconds>(500));
//	std::cout << randNum << '\n';
//	player.move(randNum);
//}

//---------------------------------------------------------------------------

void __fastcall TForm1::Button1Click(TObject *Sender)
{
	static int index{ 0 };
	Image1->Bitmap->Assign(ImageList1->Bitmap(Image1->Size->Size, index++ % 4));
}
//---------------------------------------------------------------------------

void __fastcall TForm1::Button2Click(TObject *Sender)
{
	delete Image1;
	Image1 = nullptr;
}
//---------------------------------------------------------------------------

void __fastcall TForm1::ResetButtonClick(TObject *Sender)
{
	 global_playerTurnCounter = 0;
	 for (int i = 0; i <  global_max_players; ++i){
		 playersVector[i]->resetPos(i * 30 + 3, 542.4);
	 }
}
//---------------------------------------------------------------------------

